#import "../uestc-thesis-template/lib.typ":*
= 一体式QAG系统

== 系统概述

尽管已有许多研究致力于QAG任务（如基于规则的方法、序列到序列模型或预训练语言模型），但现有解决方案仍存在以下关键问题：

- 流程割裂：数工作仅关注单一环节（如仅生成问题或答案），缺乏端到端的系统整合，用户需手动处理或依赖多个脚本输入文本、管理生成的QA对，并维护数据集，导致操作繁琐。
- 交互性不足：现有工具多为命令行或API形式，缺乏直观的用户界面（Web-UI），阻碍非技术用户（如教育工作者）的使用。


为解决上述问题，本文提出一种一体化QAG系统，通过整合文献解析、QA生成、数据集管理和用户交互界面，实现从原始文本到可部署QA数据的全流程自动化。


== QAG系统架构

#picture-figure("左：QAG_System的项目结构；右：QAG_System的页面页面结构和后端数据流。", 
            image("/src/pic/qag_system.png",width: 100%)
            )<qag_system>

整个系统的功能框架和文件结构如 @qag_system 所示，我们将论文到QA的工作过程分为三个关键环节：
- 文献处理：该环节主要完成文件的上传与解析，对文件进行预处理例如PDF转markdown、提取标题、摘要、介绍、结论等，并将处理后的文件存储到指定目录，此外该环节需要利用大模型提取实体并产生问题。
- QA管理：该环节主要完成基于Mini_RAG的答案生成,QA管理与编辑，以及完成初步的数据集创建。
- 数据集管理：该环节主要完成数据集的管理与编辑，数据集的导出与下载。
- 模型管理：该环节主要完成模型的API配置，模型参数调整以及模型测试。

=== QAG系统前后端技术框架

#picture-figure("左：QAG_system前端技术框架；右：QAG_system后端技术框架和数据流。", 
            image("/src/pic/front&back.png",width: 100%)
            )<front_back>

*Streamlit*#footnote(link("Streamlit" + "https://streamlit.io"))：Streamlit 是一个基于 Python 的开源 Web 应用程序框架，专为数据科学家和机器学习工程师设计，用于快速创建数据可视化应用。它的主要优势在于简单性和快速迭代，用户可以使用几行代码创建交互式应用，无需深入了解前端技术如 HTML、CSS 等。

*Langchain*#footnote(link("Langchain" + "https://www.langchain.com"))：LangChain 是一个用于构建基于语言模型的应用程序的框架，提供了多种工具和模块来简化与语言模型的交互。它支持多种语言模型和数据源的集成，允许用户轻松创建复杂的应用程序，如对话系统、问答系统等。


本QAG系统的前后端技术框架如 @front_back 所示，前端使用Streamlit结果进行编写，主要用到Data elements、Inpu widgets、Layout&containers等组件，后端使用Langchain进行编写，主要用到SemanticChunker、HuggingFaceEmbeddings、CrossEncoder、StreamingStdOutCallbackHandler等库，利用这些库可以有效将Mini_RAG系统与元数据和数据库整合在一起，大幅提高系统的运行效率。

=== QAG系统核心数据流

如 @qag_system 所示，一体式QAG系统的核心数据流围绕元数据（metadata）构建，当用户在文献管理页面上传文件时，系统会自动解析文件，并生成元数据，元数据包括“文件名”、“文件路径”、“文件大小”、“文件上传时间、“预处理文件存储路径”、“向量库路径”、“实体”、“QA_result”、“Chunks地址”等字段，除了上传文件的自身属性信息外，其余信息初始值为空。

用户的实时操作会优先触发元数据的更新，而元数据会和前端st.dataframe组件深度绑定进而将调整结果反映在页面上，类似的在QA管理界面其本质也是将用户的操作转换为对元数据的内容调整，而在数据库管理界面会根据用户需求将元数据转换为数据库数据单独存储，确保数据库和QA数据之间的独立性，更详细的数据流信息见 @pages 。


== QAG系统页面详情<pages>

#code-figure(
  "页面核心文件结构",
```
QAG_System/
├── pages/
│   ├── Preprocessing.py
│   ├── QA_management.py
│   ├── DB_management.py
│   └── Model_management.py
└── main_app.py
```
)<pages_file>


基于streamlit的前端架构要求，如 @pages_file 所示，所有页面都需要在main_app.py中进行注册，main_app.py中主要完成了系统的初始化和页面的调用以及导航栏的配置，其他页面都在pages目录下统一管理，每一个页面都是一个单独的python文件，页面的功能和设计都在各自的文件中进行编写。

=== 文献处理页

文献处理页主要包含文件的上传与解析，对文件进行预处理例如PDF转markdown、提取标题、摘要、介绍、结论等，并将处理后的文件存储到指定目录，此外该环节需要利用大模型提取实体并产生问题，其界面如 @preprocessing 所示，文件成功上传后，st.dataframe会读取元数据的内容并呈现在表格中，表格支持多行选中操作。

#picture-figure("文献处理页面，该页面为主页面，左侧为导航栏，右侧为页面详细结构：文献上传，预处理，提取实体，生成问题，文本嵌入，删除，下方为文献列表，上传文件即可创建。", 
            image("/src/pic/Preprocessing.png",width: 100%)
            )<preprocessing>
- 文件上传：
用户可以点击或拖动上传论文文件（限定PDF格式），系统会为该文件创建元数据，以2405.09939v2.pdf文件为例，当其正确上传后其元数据如 @pdf-load 所示。

#code-figure(
  "页面核心文件结构",
```json
{
  "标题": "2405.09939v2.pdf", 
  "上传时间": "2025-04-23 15:51:01", 
  "大小": "1.08 MB", "状态": "已上传", 
  "存储路径": "PDF/20250423155101_2405.09939v2.pdf", 
  "md路径": "", 
  "向量库路径": "", 
  "实体数量": 0, 
  "实体": [], 
  "Chunks地址": "", 
  "QA_result": []
}
```
)<pdf-load>

- 预处理：

当用户选定一行或多行文件后（无选中数据会出发警告），点击“预处理”按钮，系统会自动将选定的文件转换为markdown格式，将markdwon存储在制定目录下，并更新元数据信息，如  @yuchuli 所示。

#picture-figure("文献预处理。选择文献，点击预处理，系统会形成任务队列，按序转换，该过程不可中断，进度条显示转换过程。", 
            image("/src/pic/yuchuli.png",width: 100%)
            )<yuchuli>

转换成功后，新的元数据如 @md-ts 所示，更新“状态”为“已转换”，更新“md路径”为转换后的markdown文件存储路径。
#code-figure(
  "预处理后的元数据",
```json
{
  "标题": "2405.09939v2.pdf", 
  "上传时间": "2025-04-23 15:51:01", 
  "大小": "1.08 MB", 
  "状态": "已转换", 
  "存储路径": "PDF/20250423155101_2405.09939v2.pdf", 
  "md路径": "Markdown/2405.09939v2.md", 
  "向量库路径": "", 
  "实体数量": 0,
  "实体": [],
  "QA_result": [], 
  "Chunks地址": ""
}
```
)<md-ts>

- Markdown预览与修改：

经过预处理的文档支持查看markdown，并修改markdown,选中需要查看的数据（仅支持单条），在列表下方会出现“预览选中文件”，点击进入预览界面，可以对照PDF源文件查看并修改markdown，修改完成后点击“保存修改”，系统会自动将修改后的markdown文件存储到指定目录下,如 @markdown_edit 所示。

#picture-figure("文献预览。选中单个文件点击下方预览，列表下方会弹出预览页，可翻页查看PDF源文件，右侧为markdown内容，点击任意处激活编辑。", 
            image("/src/pic/markdown_edit.png",width: 100%)
            )<markdown_edit>


- 提取实体：

选择经过预处理的文件可以通过点击“提取实体”按钮来生成实体，首先系统会利用正则的方式提取md文件中abstract、instructions、conclusion等部分，然后利用大模型进行实体抽取，将实体存储在元数据中，该过程可以批量进行，抽取过程如 @entity_extract 所示。

#picture-figure("实体抽取。选择文献，点击抽取实体，系统会形成任务队列，按序转换，该过程不可中断，进度条显示转换过程，未完成预处理不可提取实体，届时系统会弹窗提示先进行“预处理”。", 
            image("/src/pic/choushiti.png",width: 100%)
            )<entity_extract>

抽取实体后，新的元数据如 @entity_ts 所示，更新“实体数量”为抽取出的实体数量，更新“实体”为抽取出的实体列表，此外用户也可以在列表中预览实体，默认抽取实体数量为15。

#code-figure(
  "抽取实体后的元数据(实体有省略)",
```json
{
  "标题": "2405.09939v2.pdf", 
  "上传时间": "2025-04-23 15:51:01", 
  "大小": "1.08 MB", 
  "状态": "已抽取实体", 
  "存储路径": "PDF/20250423155101_2405.09939v2.pdf", 
  "md路径": "Markdown/2405.09939v2.md", 
  "向量库路径": "", 
  "实体数量": 15, 
  "实体": [
    "SciQAG", 
    "large language models (LLMs)", 
    "QA generator", 
    "QA evaluator",  
    ... ，
    "Med-PALM", 
    "Galactica"
  ], 
  "QA_result": [], 
  "Chunks地址": ""
}

```
)<entity_ts>


- 生成问题

选中完成抽取实体文档可以进行问题生成，点击“问题生成”按钮，系统将会利用大模型生成10个围绕“实体”的科学问题，并将其存储在元数据中，问题生成过程如 @question_generate 所示。

#picture-figure("问题生成。选择文献，点击生成问题，系统会形成任务队列，按序转换，该过程不可中断，进度条显示转换过程。未完成实体抽取不可生成问题，届时系统会弹窗提示先进行“提取实体。”", 
            image("/src/pic/QG.png",width: 100%)
            )<question_generate>

生成问题后，状态会更新为“已生成问题”，问题会以列表的形式存放在“QA_result”值中，如 @question_generate_metadata 所示，随着QA生成的过程，元数据会越来约庞大，后续完成的元数据请查看附录C。

#code-figure(
  "问题生成后的元数据（有省略）",
```json                                                                             
{
  "标题": "2405.09939v2.pdf",
  "上传时间": "2025-04-23 15:51:01",
  "大小": "1.08 MB",
  "状态": "已生问题",
  "存储路径": "PDF/20250423155101_2405.09939v2.pdf",
  "md路径": "Markdown/2405.09939v2.md",
  "向量库路径": "",
  "实体数量": 15,
  "实体": [
      "SciQAG",
      "large language models (LLMs)",
      ...,
      "Galactica"
  ],
  "QA_result": [
    {
    "question": "Describe the structure ... QA dataset",
    "answer": "",
    "reference": ""
    }
  ]...,
  "Chunks地址": ""
}```
)<question_generate_metadata>

- 文本嵌入

选择经过转换的文档，点击“文本嵌入”按钮，系统会将markddown文档进行切分并转换成向量存储在本地，每个文档生成自己独立的向量库，后台具体操作流程见 @qa_generation，界面操作如 @embeding 所示。

#picture-figure("文本嵌入。选择文献，点击文本嵌入，系统会形成任务队列，按序转换，该过程不可中断，进度条显示转换过程。完成预处理后的文件均可进行文本嵌入。", 
            image("/src/pic/embeding.png",width: 100%)
            )<embeding>

完成文本嵌入后，状态会更新为“已嵌入”，向量库路径会更新为向量库的存储路径，所有的向量会独立存放在本地vector_db文件夹内，并根据论文文件名的哈希值进行命名。

- 文献删除

选中需要删除的文件，点击“删除”按钮，系统会删除掉该文件对应的元数据，并删除该文件对应的markdown文件，向量库文件，以及该文件对应的pdf文件，该过程不可逆，且会影响到QA管理页的内容。


=== QA管理页

该环节主要完成基于Mini_RAG的答案生成,QA管理与编辑，以及完成初步的数据集创建，当在文献处理页完成“生成问题”和“文本嵌入”后，QA管理页如 @qa_manage 所示。

#picture-figure("QA管理页。该页面包含生成答案、删除QA、创建数据集的功能，按钮栏下方为模块式列表，用户上传文件即可创建一个新的列表，列表可隐藏。", 
            image("/src/pic/qa_manage.png",width: 100%)
            )<qa_manage>

在QA管理页中，每篇文献会独立生成一个QA管理子页面（单独列表），未生成QA的论文会提示“尚未生成QA”。

- 生成答案

选中需要生成答案的问题，点击“生成答案”按钮，系统会调取后台Mini_RAG框架来生成答案，如 @AG 所示。

#picture-figure("生成答案。选择问题，点击生成答案，系统会形成任务队列，按序转换，该过程不可中断，页面其余部分进入不可选中状态。", 
            image("/src/pic/AG.png",width: 100%)
            )<AG>

完成答案生成后，系统会将答案和参考更新在元数据中，列表会触发读取机制，将更新后的QA数据呈现在页面中，由于RAG检索召回环节和答案生成为两个过程，因此，即使LLM因为一些原因输出有误，用户还可以通过查看参考文献自行填写答案。
// 完成该过程的页面如 @AG_finish 所示。

// #picture-figure("答案生成完成", 
//             image("/src/pic/AG_finish.png",width: 100%)
//             )<AG_finish>

- QA编辑

选中需要编辑的一组QA,在该论文列表下方会出现“双击编辑选中QA”按钮，双击后会进入QA编辑页，在该子页中，用户可以自由调整除参考文献以外的问题和答案，如 @QA_edit 所示。

#picture-figure("QA编辑。选中单条QA数据点击QA编辑，在该列表下方出现编辑栏，点击即可激活编辑状态，不保存直接取消选中QA或点击x，修改将无效，修改不可逆。", 
            image("/src/pic/qa_edit.png",width: 100%)
            )<QA_edit>

- QA删除

选中需要删除的QA,点击“删除”按钮，系统会删除该QA（问题、答案、参考文献）并更新元数据。

- 创建数据集

选择需要创建数据集的QA，点击“创建数据集”按钮，系统会弹出创建数据集的窗口，用户可以输入数据集名称，并点击“创建”按钮，系统会将选中QA（不含参考文献）从元数据中提取出来，在本地DataBase_manage目录下生成数据集文件，创建过程如 @DBG 所示。

#picture-figure("数据集创建。选中QA数据，点击“创建数据集”按钮，待用户命名数据集后（不包含后缀）系统会抽离QA数据，并生成数据集文件，文件格式为jsonl。", 
            image("/src/pic/DBG.png",width: 100%)
            )<DBG>

=== 数据集管理页

该页面主要完成数据集的管理与编辑，数据集的导出与下载，其页面如 @DBM 所示。

#picture-figure("数据集管理页。左侧：数据集导出配置栏，选中数据点击“导出”数据集后激活;右侧：包含对数据集的删除和导出按钮，删除针对单个QA和整个数据集，下方表单为DataBase_manage目录下的数据集文件。", 
            image("/src/pic/DBM.png",width: 100%)
            )<DBM>

在数据集管理页中，系统会自动读取在DataBase_manage目录下的数据集文件，每个数据集单独形成列表，用户通过列表管理数据集，在侧边栏可以配置数据集的导出细则，导出文件支持json，jsonl，csv，配置完成导出细则后，右边“导出数据集”按钮会变成“下载数据集”按钮，如 @DBP 所示。

#picture-figure("数据集导出。选择需要导出的QA数据并配置好导出设置后，点击“下载数据集”系统会将数据打包形成新的jsonl通过浏览器触发下载。", 
            image("/src/pic/DBP.png",width: 100%)
            )<DBP>

=== 模型管理页

QAG_System每个页面或多或少都使用到了LLM，而LLM通常调取API进行使用，配置一个适合自身项目的大模型需要仔细配置API,并通过充分的测试，为了用户方便配置和测试模型，本系统提供一个模型管理页来对项目使用的LLM进行全局管理，其页面如 @MM 所示。


#picture-figure("模型管理页。该页面主要用于配置系统使用的LLM，在大模型配置栏下可以配置API参数，配置完成后在下方可以测试大模型是否调用正常。", 
            image("/src/pic/MM.png",width: 100%)
            )<MM>

本系统仅支持类OpenAI式接口，用户可以根据自己的需求自行配置接口参数如密钥、模型url、模型
温度系数等参数，配置完成后点击“保存配置”，系统会将参数存储为结构化数据，我们为系统定制了统一的chatbot库，各页面通过调用该库来读取模型配置，完成全局模型统一，此外，配置好的模型可以在下方进行LLM测试，测试栏会实时返回模型输出和消耗的token数量并标注当前模型以及相关参数，方便用户进行模型调试。